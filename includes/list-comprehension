<h1 id='working-with-python-list'>Working with python list</h1><div class="highlight"><pre class="highlight plaintext"><code># Bad practice.

count = []
price_list = [1,2,3,4,5]

for i in price_list:
    count = count + i
</code></pre></div>
<p>Python lists are wonderful. They perform <code>.pop</code>, <code>.append</code> at O(1) time, as well as index operations at O(1) - combining the best of the Array and Linked List data structures.</p>

<p>However, python is horrendously slow at performing custom operations to create, edit, or filter lists. Thus, it is recommended to use either a built-in function or to use list comprehensions.</p>
<h2 id='zip'><code>zip()</code></h2><div class="highlight"><pre class="highlight plaintext"><code>x, y = [1, 2, 3], ["a", "b", "c"]
zipped = zip(x, y)
print(list(zipped))                     # [(1, "a"), (2, "b"), (3, "c")]
x2, y2 = zip(*zipped)
print(x == list(x2) and y == list(y2))  # True
</code></pre></div>
<p>You can create ordered data by <em>stitching</em>  matching pairs from different data containers.</p>

<p>Use <code>zip()</code> to pull together <em>n</em> list into a list of tuples. <code>zip()</code> also works to un-zipped a <em>n</em> dimension list.</p>
<h2 id='enumerate'><code>enumerate()</code></h2><div class="highlight"><pre class="highlight plaintext"><code>seasons = ['Spring', 'Summer', 'Fall', 'Winter']
print(list(enumerate(seasons)))                     # [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
</code></pre></div>
<p>Use <code>enumerate()</code> to create ordered data containers by attaching the index as a <strong>index</strong>:<strong>value</strong> pair.</p>
<h2 id='map'><code>map()</code></h2><div class="highlight"><pre class="highlight plaintext"><code>map(lamda x: print(x), range(10))
</code></pre></div>
<p>This is the equivalent of <code>.each</code> in Javascript or <code>.foreach</code> in Ruby. This is a top-level function.</p>

<p>Supply a function variable and <em>n</em> iterables to apply the function on.</p>
<h2 id='list-comprehension'>List comprehension</h2><div class="highlight"><pre class="highlight plaintext"><code>long_method = []
for x in range(0, 9, 2):
    long_method.append(x**2)                                            # [0, 4, 16, 36, 64]
print(x)                                                                # x persist outside. Bad practice

lamba_method = list(map(lambda x: x**2, range(0, 9, 2)))

short_method = [x ** 2 for x in range(0, 9, 2)]                         # list
generators = (x ** 2 for x in range(0, 9, 2))                           # generator
</code></pre></div>
<p>List comprehension provides a concise way of creating lists. In the long form, list comprehension is taking a block of logic (<em>function</em> + <em>loop</em>) and appying it to an iterable.</p>

<p>This has the advantage of requiring less memory capacity. When using the <strong>long method</strong>, a variable named <code>x</code> will still exist outside of the loop. But with the <strong>lambda_method</strong> , the <code>lambda x:</code> does not persist outside of the code block.</p>

<aside class="success">
    See here for more information on [generators](/iterators-and-generators/iterators-and-generators.md).
</aside>
